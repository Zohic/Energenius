struct VertexShaderInput/* SOMETIMES YOU CAN PUT HERE BULLSHIT SEMANTICS WHICH JUST MATCH INPUT LAYOUT, 
						BUT IT WILL STILL WORK, GUESS COMPILER JUST GUESSING IT */
{
	float4 position: POSITION;//POSITION TRANSFORMED (IN THIS CASE DOESNT MATTER TRANSFORMED OR NOT)
	float2 uv: TEXCOORD;//IF TYPE HERE AND IN INPUT LAYOUT SHIT LIKE "VARNAME1337" IT WILL WORK, BUT IF YOU TYPE "TEXCOORD0" IT WILL NOT 
	uint idp : SV_VertexID;
};

struct VertexShaderOutput
{
	float4 position: SV_POSITION;/*
								 IT IS IMPORTANT TO MAKE IT SV_POSITION, 
								 SO RASTERIZER KNOW YOU WANT TO SEND POSITION TO PIXEL SHADER, 
								 IT WILL BE INTERPOLATED
								 BUT HERE IN VERTEX SHADER IT IS CONSIDERED AS WORLD VERTEX POSITION 
								 TO SEND TO RASTERIZER...
								 IN CASE OF TRIANGLES/POLYGONS THERE ARE ONLY 3 POSITIONS FOR EACH, 
								 WHICH ARE GOING TO BE INTERPOLATED IN MANY PIXEL POSITIONS ON RASTERIZATION STAGE
								 */
	float2 randN2: SOMEFLOAT2_NAME1;
	uint kchau: KCHAU;
	// !!! ORDER OF OUTPUT VARIABLES IN STRUCT MATTERS !!!
};


VertexShaderOutput main(VertexShaderInput vsInput)
{
	VertexShaderOutput output;

	output.position = vsInput.position;
	output.randN2 = vsInput.uv; /* MAYBE COMPILER HERE MAKE SEMANTIC MATCH ITS BEGIN FORM. UPD: BOTH OF THEM ARE FLOAT2 SO NO NEED TO MATCH SEMANTICS, 
								  JUST INPUT VALUE HAS TO BE TEXCOORD SO IA(INPUT-ASSEBLER) KNOW YOU WANT THIS INPUT FLOAT2 TO CONTAIN UVs */
	output.kchau = vsInput.idp;

	return output;
}